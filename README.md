# Purchase Cart Service

This is an HTTP server written in GO.\
REST API specification, along with brief documentation, is available in the [purchase-cart-openapi.yaml](purchase-cart-openapi.yaml) file as OpenAPI 3.0 specification.

## API design considerations

### Endpoint
The required endpoint has to return an order id, so it is designed to create a new order resource.
It is a POST request and in case of success, it returns a 201 status code.

### Data structures
The successful response's body represents the order resource just created. It contains:
- the order id
- the total price of the order, calculated as the sum of the prices of the products
- the total VAT of the order, calculated as the sum of the VATs of the products
- the items of the order, each one containing the product id, the quantity, the price and the VAT

Error responses' bodies contain a code and an optional human-readable message.
The code is a string that can be used to identify the error in the client side.

### Data types
- the order id is a string, as it is not specified that it has to be an integer or a UUID
  - it is generated by the server, actually by the storage engine, because it ensures that it is unique without any additional development
- decimal amounts are represented as decimal numbers
  - they are rounded to a fixed number of decimal places to be consistent within the responses
    - this puts the responsibility of the rounding ont the server, so the client does not have to worry about it
  - that fixed value is centralized and can be easily migrated to a configuration file

## Architectural considerations

### Pricing
Prices storage could be decoupled to another service with that specific responsibility that this service might call via API to get the prices of the products. This way the pricing service could be reused by other services that need to know the prices of the products. \
Order's totals and VAT calculation, on the other hand, fit well in this service.

I designed the pricing storage to be local to this service for simplicity, but it could be easily decoupled thanks to the structure of the packages.

### Storage
The adopted storage engine is MongoDB
- A NoSQL database is well suited for this kind of write operations that could receive a lot of requests, and can have fast write performances.
- An order usually holds a lot of data (often denormalized) related to the order itself, but not to other orders. A documental database allows storing all the data related to an order in a single document, so it is easier to retrieve all the data in a single query without joins.
- The structure of orders tends to evolve over time, and the documental structure allows easier extending of the order data model
- The product prices too can be safely stored in a document database as they are usually retrieved with simple queries on indexed fields that can have fast performances

## Codebase

### Project structure
The application is mainly structured in the following directories:
- `cmd` contains the executable main packages.
  - `cmd/server` contains the main package that starts the HTTP server.
- `internal` contains the packages that are used internally by the application.
  - `api` contains the HTTP server definitions and the API handlers.
    - this code is **generated** by the [OpenAPI generator](.dev/scripts/generate-api.sh) starting from the OpenAPI 3.0 specification file.
  - `http` contains the HTTP server implementation that uses the API handlers.
  - `bizlogic` contains the business logic abstraction for the application.
    - `order` contains the order creation logic.
    - `pricing` contains the pricing logic.
  - `storage` contains the storage repository of the application.
    - `mongodb` contains the MongoDB storage implementation.

### Implementation considerations
- The application's packages are designed to be decoupled with interfaces and dependency injection
- The decimal numbers are managed with the https://github.com/govalues/decimal package to avoid dealing directly with floating point errors
- The VAT calculation is structured on the pattern that combines VAT class with some VAT context (e.g. the country of the customer)
to calculate the rate of VAT to apply to the product price. So product prices are bound to a VAT class instead of a VAT rate,
and the service calculates the VAT amount when necessary according to the current context.\
This way the VAT rate is decoupled from the product price. When the order is created,
instead, the calculated VAT amount is consolidated.\
However, in this simple service implementation, due to the lack of VAT context, a fixed VAT calculator is applied
under the hood.

### Dependencies
The only external tool needed is `docker`.\
Optionally, the `docker compose plugin` could be used for easier management of the development MongoDB instance

### Testing
The application is tested with **unit tests** for the business logic and the HTTP server using [generated mocked dependencies](https://github.com/uber-go/mock).\
The coverage of the unit tests is intentionally not 100% because some parts were not worth testing for the scope of this development (e.g. the generated API handlers or the decimal numbers overflow errors).

The MongoDB storage is tested with **integration tests** that use a [disposable container with a real MongoDB instance](https://github.com/ory/dockertest). These type of tests are slower than unit tests but are more realistic and can catch integration issues with the real MongoDB instance.

**End-to-end tests** are implemented with an [external tool](https://k6.io/) in the `e2e_tests` directory.
They are not automated along with the others to not complicate the project setup but can be run with the provided script to check the behavior of the running application.

## Usage

**Note**: all the following commands are intended to be run from the root of the project

Setup local environment
```bash
cp .env.example .env
```

Configurations can be customized, these are the default values.
```
# listen host and port for the HTTP server
HTTP_LISTEN_HOST=0.0.0.0
HTTP_LISTEN_PORT=9090

# MongoDB connection string and database
MONGODB_URI=mongodb://mongo:27017
MONGODB_DATABASE=purchase-cart
```
The default `MONGODB_URI` points to a MongoDB instance running in a convenience docker compose project available for
development in [.dev/docker-compose.yaml](.dev/docker-compose.yaml)
The _Using docker compose_ part of this guide will refer to it.\
Otherwise, you can run a MongoDB instance locally or on a remote server and change the `MONGODB_URI` accordingly 
(beware that the server will run inside a container too).

### Using docker

#### Build the docker image
```bash
docker build -t mytest .
```

#### Run the docker container to build the application
This will build the application executables
```bash
docker run --rm -v $(pwd):/mnt -w /mnt mytest ./scripts/build.sh
```

#### Run the docker container to test the application
This will run unit and integration tests. The MongoDB instance is started in a disposable docker container so we have to 
provide the docker socket to the container so the testing library can start the MongoDB container.
```bash
docker run --rm -v $(pwd):/mnt -v /var/run/docker.sock:/var/run/docker.sock -w /mnt mytest ./scripts/tests.sh
```

#### Run the docker container to seed some data
This will seed some product prices (the ones in the example provided for this task) in the database to test the application\
**Note**: The MongoDB instance must be running and reachable at `MONGODB_URI`
```bash
docker run --rm -v $(pwd):/mnt -w /mnt mytest ./scripts/seed-db.sh
```

#### Run the docker container to start the application
This will start the server application\
**Note**: The MongoDB instance must be running and reachable at `MONGODB_URI`
```bash
docker run --rm -v $(pwd):/mnt -p 9090:9090 -w /mnt mytest ./scripts/run.sh
```

### Using docker compose

The docker compose project is available in the [.dev/docker-compose.yaml](.dev/docker-compose.yaml) file.

#### Build the docker image
```bash
docker compose -f .dev/docker-compose.yaml build
```

#### Run the docker container to build the application
This will build the application executables.
```bash
docker compose -f .dev/docker-compose.yaml run --rm mytest ./scripts/build.sh
```

#### Run the docker container to test the application
This will run unit and integration tests.
```bash
docker compose -f .dev/docker-compose.yaml run --rm mytest ./scripts/tests.sh
```

#### Start the MongoDB instance
```bash
docker compose -f .dev/docker-compose.yaml up -d mongo
```

#### Run the docker container to seed some data
This will seed some product prices (the ones in the example provided for this task) in the database to test the application\
**Note**: The MongoDB instance must be running and reachable at `MONGODB_URI`
```bash
docker compose -f .dev/docker-compose.yaml run --rm mytest ./scripts/seed-db.sh
```

#### Run the docker container to start the application
This will start the server application\
**Note**: The MongoDB instance must be running and reachable at `MONGODB_URI`
```bash
docker compose -f .dev/docker-compose.yaml run --rm --service-ports mytest ./scripts/run.sh
```

### Other commands

#### End-to-end tests
**Note**: The server must be running and reachable at `localhost:9090`
```bash
./e2e_tests/tests.sh
```

#### Generate the API go package

```bash
.dev/scripts/generate-api.sh
docker compose -f .dev/docker-compose.yaml run --rm mytest go fmt ./internal/api/...
```
